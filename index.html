<!DOCTYPE html>
<html>
<head>
<title>Matt Basta</title>
<link type="text/css" rel="stylesheet" href="http://framecdn.serverboy.net/latest.css" />
<link type="text/css" rel="stylesheet" href="styles.css" />
</head>
<body class="sans-serif">
<div id="content">
    <h1 id="fallback_name">Matt Basta</h1> <!-- Replaced by three.js typefaces font -->
    <section id="biobox">
        <p class="overview">Builder of awesome internet things</p>
        <p class="links">
            <a href="skype:+15702129663">570-212-9663</a><br />
            <a href="http://www.linkedin.com/in/mbasta">resum&eacute;</a> &bull; <a href="http://blog.mattbasta.com/">blog</a><br />
            <a href="https://github.com/mattbasta">all my code</a> &bull; <a href="https://github.com/mattbasta/mattbasta.github.com">code for this page</a>
        </p>
    </section>
    <aside id="orb_info"></aside>
</div>
<script type="text/javascript" src="three.js"></script>
<script type="text/javascript" src="detector.js"></script>
<script type="text/javascript" src="droid_sans_bold.typeface.js"></script>
<script type="text/javascript">
<!--
if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

var viewport, scene, camera, cameraTarget, renderer;
var name_parent, name_text_geo, name_mesh, name_material, textMaterialFront, textMaterialSide;
var main_light, timeline_wrapper, timeline_objects = [], hover_object = null;
var orbiting_orbs = [];

var mouse = {x: 0, y: 0}, projector;

var rotation = 0, timeline_rotation = 0, y_velocity = 0;

var fog_remainder = 0xfdffc5; // 0xffffff - 0x02003a

function init() {
    viewport = document.createElement("div");
    document.body.appendChild(viewport);
    
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0xffffff, 0, 3000);
    
    camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 1500);
    camera.position.set(0, 400, 1000);
    scene.add(camera);
    
    cameraTarget = new THREE.Vector3(0, 330, 0);
    
    var dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
    dirLight.position.set(0, 0, 1).normalize();
    scene.add(dirLight);
    
    // Create my name at the bottom of the page.
    name_material = new THREE.MeshFaceMaterial();
    textMaterialFront = new THREE.MeshBasicMaterial({color: 0xdddddd});
    textMaterialSide = new THREE.MeshLambertMaterial({color: 0x666666});
    name_parent = new THREE.Object3D();
    name_parent.position.y = 100;
    scene.add(name_parent);
    createText();
    
    // Create the timeline.
    timeline_wrapper = new THREE.Object3D();
    timeline_wrapper.position.y = 100;
    scene.add(timeline_wrapper);
    
    renderer = new THREE.WebGLRenderer({antialias: true, maxLights: 10});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(scene.fog.color, 1);
    
    viewport.appendChild(renderer.domElement);
    
    projector = new THREE.Projector();
    
    viewport.addEventListener("mousemove", function(e) {
        rotation = Math.PI * (e.clientX / window.innerWidth - 0.5) * 0.3;
        var percent_y = e.clientY / window.innerHeight,
            percent_x = e.clientX / window.innerWidth;
        if(percent_x > 0.33 && percent_x < 0.66) {
            if(percent_y < 0.33)
                y_velocity = 1 - (percent_y * 3);
            else if(percent_y > 0.66)
                y_velocity = (percent_y - 0.66) * -3;
            else
                y_velocity = 0;
        }
        
        //scene.fog.color = fog_remainder * percent_y + 0x02003a;
        
        mouse.x = (percent_x * 2) - 1;
        mouse.y = -(percent_y * 2) + 1;
        
        var vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
        projector.unprojectVector(vector, camera);
        
        var ray = new THREE.Ray(camera.position, vector.subSelf(camera.position).normalize());
        var intersects = ray.intersectObjects(timeline_objects);
            next_hover_object = intersects.length > 0 ? intersects[0].object : null;
        if(hover_object != next_hover_object) {
            hover_object = next_hover_object;
            if(hover_object) {
                //console.log(hover_object.parent.name);
                var tl_item = hover_object.timeline_item || hover_object.parent.timeline_item;
                if(!tl_item)
                    return;
                $("#orb_info").show().html("<strong>" + tl_item.event_name + "</strong><p>" + tl_item.content + "</p>");
            } else {
                $("#orb_info").hide().html("");
            }
        }
        
    });
    viewport.addEventListener("mousedown", function(e) {
        e.preventDefault();
        if(hover_object) {
            var tl_item = hover_object.timeline_item || hover_object.parent.timeline_item;
            if(tl_item)
                window.open(tl_item.href);
        }
        // TODO: Handle click if hover_object is not null.
    });
    
}

function createText() {
    name_text_geo = new THREE.TextGeometry(
        "matt basta",
        {size: 20,
         height: 20,
         curveSegments: 3,
         font: "droid sans",
         weight: "bold",
         style: "normal",
         material: 0,
         extrudeMaterial: 1}
    );
    name_text_geo.materials = [textMaterialFront, textMaterialSide];
    name_text_geo.computeBoundingBox();
    name_text_geo.computeVertexNormals();
    
    var triangleAreaHeuristics = 0.1 * 1000;
    for(var i = 0; i < name_text_geo.faces.length; i++) {
        var face = name_text_geo.faces[i];
        if(face.materialIndex != 1) continue;
        for(var j = 0; j < face.vertexNormals.length; j++) {
            face.vertexNormals[j].z = 0;
            face.vertexNormals[j].normalize();
        }
        var va = name_text_geo.vertices[face.a].position,
            vb = name_text_geo.vertices[face.b].position,
            vc = name_text_geo.vertices[face.c].position;
        var s = THREE.GeometryUtils.triangleArea(va, vb, vc);
        if(s > triangleAreaHeuristics)
            for(var j = 0; j < face.vertexNormals.length; j++)
                face.vertexNormals[j].copy(face.normal);
    }
    
    var centerOffset = -0.5 * (name_text_geo.boundingBox.max.x - name_text_geo.boundingBox.min.x);
    name_mesh = new THREE.Mesh(name_text_geo, name_material);
    
    name_mesh.position.x = -1.7 * (name_text_geo.boundingBox.max.x - name_text_geo.boundingBox.min.x);
    name_mesh.position.y = 0;
    name_mesh.position.z = 0;
    
    name_mesh.rotation.x = 0;
    name_mesh.rotation.y = Math.PI * 2;
    name_parent.add(name_mesh);
}

function animate() {
    requestAnimationFrame(animate);
    render();
}

function render() {
    name_parent.rotation.y = rotation;
    timeline_wrapper.rotation.y = rotation / 3 + timeline_rotation;
    camera.lookAt(cameraTarget);
    renderer.clear();
    renderer.render(scene, camera);
}
-->
</script>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
<script type="text/javascript">
<!--
var page = 0, timeline = [], is_loading = false;

var rotator_interval = 1000 / 60, last_rotator_time = (new Date()).getTime();
var biobox = document.getElementById("biobox");

var timeline_rotator = setInterval(function() {
    // Figure out the coefficient of rotation so that staggered calls are
    // smoothed out.
    var now = (new Date()).getTime(),
        perc_interval = (now - last_rotator_time) / rotator_interval;
    last_rotator_time = now;
    
    // Rotate the timeline
    timeline_rotation += (hover_object == null ? 0.005 : 0.0005) * perc_interval;
    
    // If the timeline is not moving "up" at the bottom of the timeline...
    if(!(timeline_wrapper.position.y == 100 && y_velocity < 0) && y_velocity) {
        // Update the Y coordinate.
        timeline_wrapper.position.y -= y_velocity * 3.5 * perc_interval;
        timeline_wrapper.position.y = Math.min(100, timeline_wrapper.position.y);
        
        // Update the fog.
        var fog_perc = 1 - Math.min(-(timeline_wrapper.position.y - 100), 500) / 500,
            f_red = Math.floor((fog_remainder >> 16) * fog_perc),
            f_green = Math.floor(((fog_remainder - 0xfd0000) >> 8) * fog_perc),
            f_blue = Math.floor((fog_remainder - 0xfdff00) * fog_perc),
            new_fog_color = 0x02003a + (f_red << 16) + (f_green << 8) + f_blue;
        //console.log("r:" + f_red + ",g:" + f_green + ",b:" + f_blue);
        scene.fog.color = new THREE.Color(new_fog_color);
        renderer.setClearColor(scene.fog.color, 1);
        document.body.style.backgroundColor = "#" + new_fog_color.toString(16);
        biobox.style.opacity = fog_perc;
        
        // If we're off the top of the timeline, load another unit on top.
        if(!is_loading && y_velocity > 0 && timeline.length > 30 &&
           -timeline_wrapper.position.y > (timeline[timeline.length - 1].orb.position.y - 600))
            get_next_page();
    }
    
    // Rotate all of the rotating orbs.
    for(var i = 0; i < orbiting_orbs.length; i++) {
        var orb = orbiting_orbs[i];
        // TODO: Ignore orbs that are off-screen.
        orb.rotation.y += orb.rotation_speed * perc_interval;
    }
}, rotator_interval), timeline_visiblator = setInterval(function() {
    var tpos = timeline_wrapper.position.y;
    for(var i = 0; i < timeline.length; i++) {
        var item = timeline[i];
        if((item.orb.position.y + tpos < -20 ||
            item.orb.position.y + tpos > 700) && item.visible) {
            //console.log("Hiding " + item.type);
            timeline_wrapper.remove(item.orb);
            item.visible = false;
        } else if(!item.visible && (item.orb.position.y + tpos < 700 &&
                                    item.orb.position.y + tpos > -20)) {
            //console.log("Showing " + item.type);
            timeline_wrapper.add(item.orb);
            item.visible = true;
        }
    }
}, 500);


var repos = [];
var repo_angle_iteration = Math.PI * 11 / 29,
    repo_angle = repo_angle_iteration,
    repo_positions = [];
var orb_material = {
    "PushEvent": new THREE.MeshLambertMaterial({color: 0x993311}),
    "CreateEvent": new THREE.MeshBasicMaterial({color: 0xfff100}),
    "PullRequestEvent": new THREE.MeshLambertMaterial({color: 0x1133aa})
};
var addition_material = new THREE.MeshLambertMaterial({color: 0x168720}),
    deletion_material = new THREE.MeshLambertMaterial({color: 0xc01913}),
    ring_material = new THREE.LineBasicMaterial({color: 0xcccccc, linewidth: 1});
function get_next_page() {
    page++;
    var last_event = null;
    if(timeline)
        last_event = timeline[timeline.length - 1];
    is_loading = true;
    $.getJSON("https://api.github.com/users/mattbasta/events?page=" + page + "&callback=?", function(response) {
        is_loading = false;
        for(var i = 0; i < response.data.length; i++) {
            var event = response.data[i],
                mesh, radius = 0;
            
            // Identify the repository.
            var repo = event.repo.name.split("/")[1];
            if(repos.indexOf(repo) == -1)
                repos[repos.length] = repo;
            
            // Determine the orb position.
            var repo_position_position = repos.indexOf(repo)
            if(repo_position_position >= repo_positions.length) {
                repo_positions[repo_positions.length] = [
                    repo_angle,
                    repo_positions.length / 5 + 1
                ];
                repo_angle += repo_angle_iteration;
                repo_angle *= 1.05;
            }
            // Give the orb a bit of a spin
            var rpos = repo_positions[repo_position_position],
                ypos = last_event != null ? 5 + last_event.orb.position.y + last_event.radius : 20,
                xpos = Math.sin(rpos[0] + Math.pow(ypos, 1.05) / 300) * rpos[1] * 10 * Math.log(ypos),
                zpos = Math.cos(rpos[0] + Math.pow(ypos, 1.05) / 300) * rpos[1] * 10 * Math.log(ypos);
            
            // Build the orb timeline information object.
            var item = {type: event.type,
                        repo: repo,
                        parent: last_event,
                        href: "https://github.com/mattbasta"};
            switch(event.type) {
                case "PushEvent":
                    item.event_name = "Pushed Commits";
                    item.content = "<p>Matt pushed " + event.payload.size + " commit" + (event.payload.size > 1 ? "s" : "") + " to " + event.repo.name + "</p>";
                    item.href = event.payload.commits[0].url;
                    radius = 4;
                    mesh = new THREE.Object3D();
                    var orb = new THREE.Mesh(
                        new THREE.SphereGeometry(radius, 7, 12),
                        orb_material[event.type]
                    );
                    mesh.add(orb);
                    for(var j = 0; j < Math.min(event.payload.size, 8); j++) {
                        var commit_orb = new THREE.Mesh(
                            new THREE.SphereGeometry(radius / 2, 4, 6),
                            orb_material[event.type]
                        );
                        var orbit_radius = radius + j * 9 + 3;
                        commit_orb.position.x = orbit_radius;
                        var commit_orb_wrap = new THREE.Object3D();
                        commit_orb_wrap.rotation.y = Math.random() * Math.PI * 2;
                        commit_orb_wrap.rotation.z = (Math.random() - 0.5) * 0.2;
                        commit_orb_wrap.rotation_speed = 0.1 / Math.pow(j + 0.8, 2);
                        commit_orb_wrap.add(commit_orb);
                        
                        // Add the ring for the orbit.
                        var x2, z2;
                        var temp = 2 * Math.PI - Math.PI / 4,
                            ring_increment = Math.PI / Math.max(j, 6);
                        var ring = new THREE.Object3D();
                        for(var k = 0; k < 2 * Math.PI + ring_increment; k += ring_increment) {
                            var x = Math.sin(k) * orbit_radius, z = Math.cos(k) * orbit_radius;
                            if(k == 0) {
                                x2 = x;
                                z2 = z;
                                continue;
                            }
                            var line_geom = new THREE.Geometry();
                            line_geom.vertices.push(new THREE.Vertex(new THREE.Vector3(x, 0, z)),
                                                    new THREE.Vertex(new THREE.Vector3(x2, 0, z2)));
                            ring.add(new THREE.Line(line_geom, ring_material));
                            x2 = x;
                            z2 = z;
                        }
                        ring.rotation.z = commit_orb_wrap.rotation.z;
                        mesh.add(ring);
                        if(Math.random() > 0.5)
                            commit_orb_wrap.rotation_speed *= -1;
                        
                        orbiting_orbs.push(commit_orb_wrap);
                        mesh.add(commit_orb_wrap);
                    }
                    break;
                case "CreateEvent":
                    if(last_event != null && last_event.repo == repo && last_event.type == "PullRequestEvent")
                        continue;
                    item.event_name = "Created Branch";
                    item.href = event.repo.url;
                    radius = 15;
                    mesh = new THREE.Mesh(
                        new THREE.SphereGeometry(5, 20, 15),
                        orb_material[event.type]
                    );
                    var glower = new THREE.PointLight(0xfffd99, 3, 500);
                    glower.position.x = xpos;
                    glower.position.z = zpos;
                    glower.position.y = last_event == null ? 20 : 5 + last_event.orb.position.y + radius + last_event.radius;
                    timeline_wrapper.add(glower);
                    
                    for(var event_type in orb_material)
                        renderer.initMaterial(orb_material[event_type], scene.lights, scene.fog);
                    renderer.initMaterial(addition_material, scene.lights, scene.fog);
                    renderer.initMaterial(deletion_material, scene.lights, scene.fog);
                    
                    break;
                case "PullRequestEvent":
                    item.event_name = "Pull Request";
                    item.href = event.payload.pull_request._links.html.href;
                    radius = (event.payload.pull_request.additions + event.payload.pull_request.deletions) / 100 + 5;
                    radius = Math.min(radius, 30);
                    mesh = new THREE.Object3D();
                    var orb = new THREE.Mesh(
                        new THREE.SphereGeometry(radius, 20, 15),
                        orb_material[event.type]
                    );
                    mesh.add(orb);
                    var addition_files = event.payload.pull_request.additions / event.payload.pull_request.deletions * event.payload.pull_request.changed_files;
                    for(var j = 0; j < Math.min(event.payload.pull_request.changed_files, 30); j++) {
                        var file_orb = new THREE.Mesh(
                            new THREE.SphereGeometry(1.5, 3, 6),
                            j > addition_files ? deletion_material : addition_material
                        );
                        file_orb.position.x = radius + 6;
                        var file_orb_wrap = new THREE.Object3D();
                        file_orb_wrap.add(file_orb);
                        file_orb_wrap.rotation.y = Math.random() * Math.PI * 2;
                        file_orb_wrap.rotation.z = (Math.random() - 0.5) * 0.6;
                        file_orb_wrap.rotation_speed = 0.01 * Math.random() + 0.005;
                        orbiting_orbs.push(file_orb_wrap);
                        mesh.add(file_orb_wrap);
                    }
                    break;
                default:
                    continue;
            }
            item.radius = radius;
            
            mesh.position.y = ypos + radius;
            
            mesh.position.x = xpos;
            mesh.position.z = zpos;
            
            mesh.timeline_item = item;
            timeline_objects.push(mesh);
            item.orb = mesh;
            timeline.push(item);
            last_event = item;
            
            if(item.visible = (mesh.position.y + timeline_wrapper.position.y < 700))
                timeline_wrapper.add(mesh);
        }
        if(timeline.length < 30)
            get_next_page();
    });
}

if (Detector.webgl) {
    document.getElementById("fallback_name").style.display = "none";
    document.body.className += " webgl";
    get_next_page();
    init();
    animate();
}
-->
</script>
</body>
</html>